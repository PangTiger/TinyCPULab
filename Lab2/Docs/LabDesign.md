# 自己动手写CPU-实验二
by CPU兴趣小组

## 数据相关的实现
### 数据相关(Data dependence/hazard)的概念
在我们的五级流水线的模型中, 读取通用寄存器堆/获得源操作数的过程发生在译码级, 而写入寄存器堆的过程只发生在写回级. 

数据相关, 顾名思义, 我们能够知道这是在描述数据之间的相互关系, 根据前后两条指令之间写/读寄存器的特点, 我们能够归纳出三种数据相关的关系. 

1. Read after write, 先写后读, 前一条指令进入流水线后将会写入目的寄存器, 而后一条指令依赖前一条指令所修改的寄存器的值. 此时就要求目的寄存器"最新的值"能够被传递给后一条指令. 如果没有及时的将前一条指令的写寄存器的结果及时的传递给后面的指令, 就会引发错误结果. 
Example: 以算术指令为例, 由于指令执行的结果会在执行级就能够得到, 但是直到写回级才能写入寄存器堆, 此时如果后面一条指令依赖当前指令的结果, 就必须将指令执行得到的结果前推给后面的指令, 否则后面的指令在译码级得到的源操作数将会是"旧"的, 将会导致运行错误.
2. Write after read, 先读后写, 前一条指令先读寄存器堆, 但后一条指令会写入寄存器堆, 如果二者的寄存器相同是否会产生错误呢? 在我们的流水线模型中, 这两条指令是会按照顺序正常执行的, 先进入流水线的指令不会读到后进入流水线指令的结果(这是一句正确的废话), 所以先读后写是不会产生错误结果的.
3. Write after write, 先写后写, 参考上一点的叙述, 这种情况在我们的CPU模型里也不会引发错误.

### 先写后读数据相关的解决方法

我们采取"数据前推"的方法, 将执行级/访存级/写回级中与"写入寄存器堆"这件任务有关的信息都推给译码级, 这样译码级仿佛有"全局视野"一样, 能够得知此时流水线中任意一条指令写寄存器的情况. 那么具体需要把哪些信息推给译码级呢?

- 写寄存器使能信号(该指令是否会写寄存器)
- 写寄存器地址
- 写寄存器的值

而我们实验1中的代码没有实现"数据前推", 我们是通过将相邻两条指令之间插入多个空指令来解决数据相关的(这种实现的方法显然效率很低).

#### 实际的数据相关的情况

1. 译码-执行级相关
2. 译码-访存级相关
3. 译码-写回级相关

TIPS:
1. 如果以上三种相关有不止一种发生, 译码级该取哪一级前推的数据?

#### 译码级需要的改动
从总体概念上考虑, 译码级读取源操作数时, 需要对源寄存器的地址和其他流水级前推过来的目的寄存器的地址进行比对, 如果发现地址一致, 并且前推过来的写使能信号是拉高的, 说明其他流水级中的指令会对此时译码级需要的源寄存器的值进行修改, 此时从寄存器堆读到的寄存器的值不是"最新的", 所以就要将译码级的读到的寄存器的值取为数据前推的值, 而从寄存器堆读端口读到的"旧的"值需要忽略掉.

TIPS: 
1. 译码级的module需要增加接口, 接收来自其他流水级的必要的信号.
2. 你需要定义一些内部信号来帮助你完成这个设计. 比如用两级逻辑来搭建: 首先判断一下哪两级之间有"数据相关", 产生三个使能信号(位选信号), 再通过一个MUX将多个流水级的前推数据选出一个赋给译码级的新的内部变量(我们可以定义为new_rd1, new_rd2, 用于和以前的寄存器堆读端口读到的寄存器值进行区分).
3. DVT中更改stage_id的端口后, 他的上一层文件minimips.sv中会提示你可以quick fix掉stage_id的端口声明, 这样不需要再手动修改例化时的端口声明.


#### 执行级 访存级 写回级需要的改动
只需要将stage_ex stage_mem stage_wb 的端口中写寄存器使能信号&写寄存器地址&写寄存器的值通过连线的方式接到译码级module的输入端口即可.

TIPS:
1. 这里的改动应该只需要在minimips.sv这个顶层文件中进行, 因为原本的stage_ex stage_mem stage_wb已经有输出必要信息的端口了.

#### 测试汇编代码
```
lui  $at, 0x1234         # $at($1) = 0x12340000
ori  $at, $at, 0xabcd    # $at($1) = 0x1234abcd
lui  $v0, 0x1230         # $v0($2) = 0x12300000
ori  $v0, $v0, 0xabcd    # $v0($2) = 0x1230abcd
subu $v1, $at, $v0       # $v1($3) = $at - $v0 = 0x40000
mult $v0, $v1            # hi = 0x48c2 lo = 0xaf340000
```

#### 正确结果
<img src=".\fig\dp-ans.png" width="700">

注意:图中的"123"是没有显示完整的.