# 自己动手写CPU-实验三
by CPU兴趣小组

## 数据相关的实现
### 数据相关(Data dependence/hazard)的概念
在我们的五级流水线的模型中, 读取通用寄存器堆/获得源操作数的过程发生在译码级, 而写入寄存器堆的过程只发生在写回级. 

数据相关, 顾名思义, 我们能够知道这是在描述数据之间的相互关系, 根据前后两条指令之间写/读寄存器的特点, 我们能够归纳出三种数据相关的关系. 

1. Read after write, 先写后读, 前一条指令进入流水线后将会写入目的寄存器, 而后一条指令依赖前一条指令所修改的寄存器的值. 此时就要求目的寄存器"最新的值"能够被传递给后一条指令. 如果没有及时的将前一条指令的写寄存器的结果及时的传递给后面的指令, 就会引发错误结果. 
Example: 以算术指令为例, 由于指令执行的结果会在执行级就能够得到, 但是直到写回级才能写入寄存器堆, 此时如果后面一条指令依赖当前指令的结果, 就必须将指令执行得到的结果前推给后面的指令, 否则后面的指令在译码级得到的源操作数将会是"旧"的, 将会导致运行错误.
2. Write after read, 先读后写, 前一条指令先读寄存器堆, 但后一条指令会写入寄存器堆, 如果二者的寄存器相同是否会产生错误呢? 在我们的流水线模型中, 这两条指令是会按照顺序正常执行的, 先进入流水线的指令不会读到后进入流水线指令的结果(这是一句正确的废话), 所以先读后写是不会产生错误结果的.
3. Write after write, 先写后写, 参考上一点的叙述, 这种情况在我们的CPU模型里也不会引发错误.

### 先写后读数据相关的解决方法

我们采取"数据前推"的方法, 将执行级/访存级/写回级中与"写入寄存器堆"这件任务有关的信息都推给译码级, 这样译码级仿佛有"全局视野"一样, 能够得知此时流水线中任意一条指令写寄存器的情况. 那么具体需要把哪些信息推给译码级呢?

- 写寄存器使能信号(该指令是否会写寄存器)
- 写寄存器地址
- 写寄存器的值

而我们实验1中的代码没有实现"数据前推", 我们是通过将相邻两条指令之间插入多个空指令来解决数据相关的(这种实现的方法显然效率很低).

#### 实际的数据相关的情况

1. 译码-执行级相关
2. 译码-访存级相关
3. 译码-写回级相关

TIPS:
1. 如果以上三种相关有不止一种发生, 译码级该取哪一级前推的数据?

#### 译码级需要的改动
从总体概念上考虑, 译码级读取源操作数时, 需要对源寄存器的地址和其他流水级前推过来的目的寄存器的地址进行比对, 如果发现地址一致, 并且前推过来的写使能信号是拉高的, 说明其他流水级中的指令会对此时译码级需要的源寄存器的值进行修改, 此时从寄存器堆读到的寄存器的值不是"最新的", 所以就要将译码级的读到的寄存器的值取为数据前推的值, 而从寄存器堆读端口读到的"旧的"值需要忽略掉.

TIPS: 
1. 译码级的module需要增加接口, 接收来自其他流水级的必要的信号.
2. 你需要定义一些内部信号来帮助你完成这个设计. 比如用两级逻辑来搭建: 首先判断一下哪两级之间有"数据相关", 产生三个使能信号(位选信号), 再通过一个MUX将多个流水级的前推数据选出一个赋给译码级的新的内部变量(我们可以定义为new_rd1, new_rd2, 用于和以前的寄存器堆读端口读到的寄存器值进行区分).
3. DVT中更改stage_id的端口后, 他的上一层文件minimips.sv中会提示你可以quick fix掉stage_id的端口声明, 这样不需要再手动修改例化时的端口声明.


#### 执行级 访存级 写回级需要的改动
只需要将stage_ex stage_mem stage_wb 的端口中写寄存器使能信号&写寄存器地址&写寄存器的值通过连线的方式接到译码级module的输入端口即可.

TIPS:
1. 这里的改动应该只需要在minimips.sv这个顶层文件中进行, 因为原本的stage_ex stage_mem stage_wb已经有输出必要信息的端口了.

#### 测试汇编代码
```
lui  $at, 0x1234         # $at($1) = 0x12340000
ori  $at, $at, 0xabcd    # $at($1) = 0x1234abcd
lui  $v0, 0x1230         # $v0($2) = 0x12300000
ori  $v0, $v0, 0xabcd    # $v0($2) = 0x1230abcd
subu $v1, $at, $v0       # $v1($3) = $at - $v0 = 0x40000
mult $v0, $v1            # hi = 0x48c2 lo = 0xaf340000
```

#### 正确结果
<img src=".\fig\dp-ans.png" width="700">

注意:图中的"123"是没有显示完整的12340000.

## 转移指令的实现

### 转移指令编码
下面列出的五条指令是"计算机系统设计"书中第六章实现的五条转移指令, 这五条指令如下图所示
<img src=".\fig\J.png" width="700">

<img src=".\fig\JAL1.png" width="700">

<img src=".\fig\JAL2.png" width="700">

<img src=".\fig\JAL3.png" width="700">

<img src=".\fig\BEQ.png" width="700">

<img src=".\fig\BNE.png" width="700">

<img src=".\fig\BNE2.png" width="700">

### 转移指令的分类
转移指令分为无条件转移和有条件转移. 所谓的无条件的转移就是直接跳转, 例如J JAL JR指令, 而BEQ和BNE还需要判断条件, 对rs和rt字段寄存器的值进行比较, 满足条件才发生分支. 

由指令编码可以看出, J和JAL指令都是J型指令, 而JR其实是是R型指令, BEQ和BNE是I型指令. 可以看到部分转移指令会读寄存器堆的值, 还有一些转移指令会写寄存器堆, 这些特点都要纳入设计的考虑之中.

### 原框架需要的修改

#### 译码级
##### 增加模块端口
译码级需要在原来的基础上增加接口: 转移目的地址, 是否发生转移.

##### 增加内部信号
判断是否跳转: 
1. 无条件跳转的指令一定会跳转.
2. 有条件的指令, 需要按照指令的要求, 在译码级增加用于比较的电路.

跳转的目的地址
1. J型指令(J和JAL)直接取低位的offset即可.
2. R型指令(JR), 需要用到rs字段的值.
3. I型指令BNE和BEQ, 按照指令集定义实现即可.

TIPS: 这里的实现是不是需要一个MUX?
